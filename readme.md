# RESTful dotnet Core API 

## To get it running
- ``docker ps`` to check if docker container is running, if it isnt: ``docker start sql_server_dotnetAPI_demo``
- to see inside database type: ``mssql -d 'Parky' -u sa -p reallyStrongPwd123`` (where 'Parky' is the name of the database)
- to perform a query, type: ``SELECT * FROM NationalParks`` (sql stuff)

api means "Application Programming Interface" => a software intermediary that allows two applications to talk to each other

It works via request and response

### The request object
verb
headers
content

HTTP Verbs / actions:
 - GET: fetches/requests 
 - POST: creates/inserts resource
 - PUT: updates/modifies resource
 - PATCH: updates/modifies *partial* resource (use if you only want to update part of the resource)
 - DELETE: deletes/removes resource
 - more verbs..(not often used)

Headers:
name-value pairs that are meta data about the request
 - Content type: Content's format
 - Content Length: size of the content
 - Authorization: who is making the request
 - Accept: what are the accepted type(s)
 - more headers... 

Content:
This could be anything
  - HTML, CSS, XML, JSON
  - Information for the request
  - Blobs etc

### The response object
status code
headers
content

Status Codes: 
  - 100-199 => informational
  - 200-299 => success
    - 200 - OK
    - 201 - Created
    - 204 - No Content
  - 300-399 => redirection 
  - 400-499 => Client Errors
    - 400 - bad request
    - 404 - not found
    - 409 - conflict
  - 500-599 => server errors
    - 500 - internal server error

Headers: 
response's metadata
  - Content type: contents format
  - Content length: size of the content
  - Expires: when is this invalid
  - more headers...

Content:
  - HTML, CSS, XML, JSON
  - Blobs etc.


## Creating project
mkdir fileName
cd fileName
dotnet new webapi

on side menu on the > icon, click and then click "run" with .NET Core selected

===

to start new files off: create a folder like normal in vs code, then create a class simply type "className.cs", remember to setup the namespace.

to install a package, need to type in the console: ``"dotnet add package Microsoft.EntityFrameworkCore"`` for example, which will add it to the csproj file.

to fix red underlined stuff, click on it then go command + . 

===

### Database stuff

(he uses sql server, i needed to run it on docker)

in startup.cs options.usesqlserver needs ``"dotnet add package Microsoft.EntityFrameworkCore.SqlServer"``

in appsettings.json for a sqlserver hosted in docker, need to use something like: 
``"DefaultConnection": "Server=localhost,1433;Database=Parky;User Id=SA;Password=reallyStrongPwd123;"``

"Add-Migration dbName" doesn't work in vs code, need to: 
``dotnet ef migrations add dbName``
=> might need to install dotnet ef seperately? its globally installed now on the mac tho, if need to install its ``dotnet tool install --global dotnet-ef``

it will generate a migrations folder, he recommends moving it into the data folder. won't actually update the tables in databae though, need to run
``dotnet ef database update``
==> the above command will officially add it to the database


DTO's: 
Domain model:
National Park
- ID
- Name
- State
- Established date
- Image
- Created date
- Updated date

Create DTO:
- Name
- State
- Established date
- Image
(wont be an id/created date/updated date, auto generated by database)

Update DTO:
- ID
- Name
- State
- Established date
- Image

===

## API Documentation 

Adds the following libraries:
SwashBuckle.AspNetCore.Swagger
SwashBuckle.AspNetCore.SwaggerGen
SwashBuckle.AspNetCore.SwaggerUi

NOTE: Adding SwashBuckle.AspNetCore gets all the above 3 by default!
``dotnet add package SwashBuckle.AspNetCore``

In startup.cs needed to add this to ConfigureServices:
````cs
  services.AddSwaggerGen(options => {
      options.SwaggerDoc("ParkyOpenAPISpec",
          new Microsoft.OpenApi.Models.OpenApiInfo() {
              Title = "Parky API",
              Version = "1"
          });
  });
````
and this to Configure: 
````cs
app.UseSwagger();
app.UseSwaggerUI(options => {
  options.SwaggerEndPoint("/swagger/ParkyOpenAPISpec/swagger.json", "Parky API");
});
````

to check swagger stuff go to: 
https://localhost:5001/swagger/ParkyOpenAPISpec/swagger.json
"info" shows the info declared in the openApiInfo set in ConfigureServices
"paths" shows all the routes that our API exposes. Note responses are incomplete / inaccurate

and this to Configure: 
````cs
app.UseSwaggerUI(options => {
  options.SwaggerEndPoint("/swagger/ParkyOpenAPISpec/swagger.json", "Parky API");
  options.RoutePrefix = ""; //helps to make /swagger the default route
});
````
to check swagger stuff now at: 
https://localhost:5001/swagger/
=> Can test api's from the above link! Works like postman.

### Improving documentation with XML comments

"Extensible Markup Language (XML) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable"

Add more info:
````cs
/// <summary>
/// Get individual national park
/// </summary>
/// <param name="nationalParkId"> The Id of the national Park </param>
/// <returns></returns>
[HttpGet("{id:int}", Name = "GetNationalPark")]
public IActionResult GetNationalPark(int id)
{
  var obj = _npRepository.GetNationalPark(id);
  if (obj == null)
  {
    return NotFound();
  }

  var objDto = _mapper.Map<NationalParkDto>(obj);
  return Ok(objDto);
}
````

in csproj file add something like: 

````
<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
  <DocumentationFile>bin\Debug\$(TargetFramework)\$(MSBuildProjectName).xml</DocumentationFile>
  <NoWarn>1701;1702;1705;1591</NoWarn>
</PropertyGroup>

//i.e:
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>bin\Debug\netcoreapp3.1\ParkyAPI.xml</DocumentationFile>
    <NoWarn>1701;1702;1705;1591</NoWarn>
  </PropertyGroup>
````

Need to update swagger doc code: 
````cs
services.AddSwaggerGen(options => {
    options.SwaggerDoc("ParkyOpenAPISpec",
        new Microsoft.OpenApi.Models.OpenApiInfo() {
            Title = "Parky API",
            Version = "1"
        });
    var xmlCommentFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var cmlCommentsFullPath = Path.Combine(AppContext.BaseDirectory, xmlCommentFile);
    options.IncludeXmlComments(cmlCommentsFullPath);
});
````

To fix up response types in swagger, need to add "producesResponseType", like so: 
````cs
/// <summary>
    /// Get list of national parks.
    /// </summary>
    /// <returns></returns>
    [HttpGet]
    [ProducesResponseType(200, Type = typeof(List<NationalParkDto>))] //need to add this (returning Ok() is a 200 response type)
    [ProducesResponseType(400)] // and this (auto handled by dotnet core)
    public IActionResult GetNationalParks()
    {
      var objList = _npRepository.GetNationalParks();
      var objDto = new List<NationalParkDto>();

      foreach(var obj in objList) {
        objDto.Add(_mapper.Map<NationalParkDto>(obj));
      }

      return Ok(objDto);
    }
````

````cs
[ApiController]
  [Route("api/[controller]")]
  [ProducesResponseType(StatusCodes.Status400BadRequest)] //since 404 is generic accross all routes, can add this to the top before the class!
  public class NationalParksController : ControllerBase
  {
    private readonly INationalParkRepository _npRepository;
    private ...
````


===

### Order for adding trails

1. Add model to models file: 
create Tails.cs => fill out class file
2. Add dto to models=>dtos file:
3. Add trail repository 
4. Add trail interface (ITrailRepository)
5. Add migration... ``dotnet ef migrations add AddTrailToDb`` and ``dotnet ef database update``

What is a repository?
"Conceptually, a Repository encapsulates the set of objects persisted in a data store and the operations performed over them, providing a more object-oriented view of the persistence layer"
(In this project, it seperates out some logic from the controller)

===

### Versioning

For versioning, make a copy of a controller and call if V2

need to install two new packages: ``dotnet add package Microsoft.AspNetCore.Mvc.Versioning``